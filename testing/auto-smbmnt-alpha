#!/bin/bash

# shellcheck disable=SC2034
SCRIPT_NAME="smbmnt"
SCRIPT_VERSION="2.1"
SCRIPT_AUTHOR="appaKappaK"
SCRIPT_DESCRIPTION="Samba mount management utility"

if [ -n "$SUDO_USER" ]; then
    ACTUAL_USER_HOME=$(getent passwd "$SUDO_USER" | cut -d: -f6)
else
    ACTUAL_USER_HOME="$HOME"
fi

DEFAULT_SERVER="YourSambaIP"
DEFAULT_CREDENTIALS="$ACTUAL_USER_HOME/.smbcredentials"
DEFAULT_SHARES=("ShareName" )
MOUNT_BASE="/mnt" # or /smb
CACHE_DIR="$ACTUAL_USER_HOME/.cache/smbmnt"
NETWORK_SCAN_PREFERENCE="" # 192...|10...
SMB_VERSION="3.1.1"
LOG_FILE="$CACHE_DIR/smbmnt.log"
NMAP_OPTIONS=(-Pn -n -p 445 --open --min-rate 1000)
DISCOVERED_SERVERS_FILE="$CACHE_DIR/discovered_servers"

RED='\033[0;31m' 
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

mkdir -p "$CACHE_DIR"
touch "$LOG_FILE" 2>/dev/null && chmod 644 "$LOG_FILE" 2>/dev/null

log_message() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local log_entry
    log_entry="$timestamp [$level] $message"
    
    # Log to file
    echo "$log_entry" >> "$LOG_FILE"
    
    # Print to console with colors intact
    echo -e "$message"
}

rotate_log_if_needed() {
    local max_size_mb=10
    if [ -f "$LOG_FILE" ] && [ "$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null)" -gt $((max_size_mb * 1024 * 1024)) ]; then
        mv "$LOG_FILE" "$LOG_FILE.old"
        touch "$LOG_FILE"  
        chmod 644 "$LOG_FILE" 2>/dev/null
        log_message "INFO" "${YELLOW}Rotated log file (> ${max_size_mb}MB)${NC}"
    fi
}

validate_server() {
    local server="$1"
    # More comprehensive IP validation
    if [[ "$server" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        # Validate each octet is between 0-255
        IFS='.' read -r -a octets <<< "$server"
        for octet in "${octets[@]}"; do
            if ((octet < 0 || octet > 255)); then
                log_message "ERROR" "${RED}Invalid IP address: $server${NC}"
                return 1
            fi
        done
        return 0
    elif [[ "$server" =~ ^[a-zA-Z0-9.-]+$ ]] && [[ "${#server}" -le 253 ]]; then
        # Validate hostname format and length
        return 0
    else
        log_message "ERROR" "${RED}Invalid server format: $server${NC}"
        return 1
    fi
}

validate_number() {
    local input="$1"
    local max="$2"
    
    # Check if input is a number
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    
    # Check if within valid range
    if [ "$input" -ge 1 ] && [ "$input" -le "$max" ] 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

initialize_script() {
    show_header
    rotate_log_if_needed
    log_message "INFO" "${CYAN}Starting $SCRIPT_NAME v$SCRIPT_VERSION${NC}"
    log_message "DEBUG" "User: $USER, Home: $ACTUAL_USER_HOME"
    log_message "DEBUG" "Mount base: $MOUNT_BASE, Cache: $CACHE_DIR"
    return 0
}

check_dependency() {
    local dep="$1"
    if ! command -v "$dep" &> /dev/null; then
        log_message "ERROR" "${RED}Missing dependency: $dep${NC}"
        return 1
    fi
    return 0
}

detect_package_manager() {
    if command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v apt-get &> /dev/null; then
        echo "apt"
    elif command -v pacman &> /dev/null; then
        echo "pacman"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v zypper &> /dev/null; then
        echo "zypper"
    else
        echo "unknown"
    fi
}

get_package_name() {
    local dep="$1"
    case "$dep" in
        nmap)
            echo "nmap"
            ;;
        smbclient)
            echo "samba-client"
            ;;
        nmblookup)
            echo "samba-client"
            ;;
        cifs-utils)
            echo "cifs-utils"
            ;;
        *)
            echo "$dep"
            ;;
    esac
}

install_dependency() {
    local dep="$1"
    local pkg_manager="$2"
    local pkg_name
    pkg_name=$(get_package_name "$dep")
    
    log_message "INFO" "${YELLOW}Attempting to install $dep ($pkg_name)...${NC}"
    
    case "$pkg_manager" in
        dnf|yum)
            sudo "$pkg_manager" install -y "$pkg_name"
            ;;
        apt)
            sudo apt-get update && sudo apt-get install -y "$pkg_name"
            ;;
        pacman)
            sudo pacman -S --noconfirm "$pkg_name"
            ;;
        zypper)
            sudo zypper install -y "$pkg_name"
            ;;
        *)
            log_message "ERROR" "${RED}Unknown package manager: $pkg_manager${NC}"
            return 1
            ;;
    esac
    
    if [ $? -eq 0 ]; then
        log_message "INFO" "${GREEN}Successfully installed $dep${NC}"
        return 0
    else
        log_message "ERROR" "${RED}Failed to install $dep${NC}"
        return 1
    fi
}

check_dependencies() {
    local deps=("nmap" "smbclient")
    local missing=()
    local pkg_manager
    pkg_manager=$(detect_package_manager)

    # First pass: check what's missing
    for dep in "${deps[@]}"; do
        if ! check_dependency "$dep"; then
            missing+=("$dep")
        fi
    done

    if [ ${#missing[@]} -eq 0 ]; then
        return 0
    fi

    log_message "WARNING" "${YELLOW}Missing dependencies: ${missing[*]}${NC}"
    
    # Offer to install missing dependencies
    if [ "$pkg_manager" != "unknown" ]; then
        echo
        read -r -p "Do you want to attempt to install missing dependencies? (y/N): " install_choice
        if [[ "$install_choice" =~ ^[Yy]$ ]]; then
            local failed_installs=()
            
            for dep in "${missing[@]}"; do
                if ! install_dependency "$dep" "$pkg_manager"; then
                    failed_installs+=("$dep")
                fi
            done
            
            if [ ${#failed_installs[@]} -gt 0 ]; then
                log_message "ERROR" "${RED}Failed to install: ${failed_installs[*]}${NC}"
                log_message "INFO" "${YELLOW}Please install these manually and try again.${NC}"
                return 1
            else
                log_message "INFO" "${GREEN}All dependencies installed successfully!${NC}"
                return 0
            fi
        else
            log_message "INFO" "${YELLOW}Skipping automatic installation. Please install manually:${NC}"
            for dep in "${missing[@]}"; do
                local pkg_name
                pkg_name=$(get_package_name "$dep")
                log_message "INFO" "  - $pkg_name (provides $dep)"
            done
            return 1
        fi
    else
        log_message "ERROR" "${RED}Could not detect package manager. Please install manually:${NC}"
        for dep in "${missing[@]}"; do
            log_message "INFO" "  - $dep"
        done
        return 1
    fi
}

check_optional_dependencies() {
    local optional_deps=("nmblookup" "cifs-utils")
    local missing_optional=()
    
    for dep in "${optional_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_optional+=("$dep")
        fi
    done
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        log_message "INFO" "${YELLOW}Optional dependencies missing (features may be limited): ${missing_optional[*]}${NC}"
    fi
    
    return 0
}

show_usage() {
    echo "Usage: smbmnt [OPTIONS] [CHOICE]"
    echo ""
    echo "OPTIONS:"
    echo "  -ip, --server IP          Samba server IP/hostname (default: $DEFAULT_SERVER)"
    echo "  -c, --credentials         Credentials file (default: $DEFAULT_CREDENTIALS)"
    echo "  --mount-base              Base mount directory (default: $MOUNT_BASE)"
    echo "  -ls, --list               List available shares"
    echo "  -u, --unmount             Unmount shares"
    echo "  -S, --scan                Discover SMB servers on network"
    echo "  -Ss, --scan-shares IP     List shares on specific server"
    echo "  -st, --status             Show dashboard"
    echo "  -D, --discovered          Use discovered servers instead of default"
    echo "  --fstab                   Generate fstab entries for selected shares"
    echo "  -h, --help                Show this help"
    echo ""
    echo "CHOICE:"
    echo "  1-N               Mount specific share number"
    echo "  1,2,3             Mount multiple shares (comma-separated)"
    echo "  all               Mount all shares"
    echo "  (none)            Interactive mode"
    echo ""
    echo "Examples:"
    echo "  smbmnt -S                      # Discover servers on local network"
    echo "  smbmnt -S 192.168.0.0/24       # Scan specific network"
    echo "  smbmnt -Ss 10.8.0.1            # Scan for shares on a specific server"
    echo "  smbmnt -D                      # Use a discovered server"
    echo "  smbmnt --fstab 2               # Generate fstab for shares (1,2,3...)"
}

detect_network() {
    if [ -n "$NETWORK_SCAN_PREFERENCE" ]; then
        echo "$NETWORK_SCAN_PREFERENCE"
        return 0
    fi

    local network
    network=$(ip -4 route show 2>/dev/null | grep -v "default" | grep -E "(192\.168|10\.|172\.)" | awk '{print $1}' | head -n1)

    if [ -z "$network" ]; then
        local gateway
        gateway=$(ip route show default 2>/dev/null | awk '{print $3}' | head -n1)
        if [ -n "$gateway" ]; then
            network=$(echo "$gateway" | sed 's/\.[0-9]*$/\.0\/24/')
        fi
    fi

    if [ -z "$network" ]; then
        log_message "ERROR" "${RED}Could not detect network. Run -S <network>.${NC}"
        return 1
    fi

    echo "$network"
}

discover_servers() {
    local network="$1"

    if [ -z "$network" ]; then
        if ! network=$(detect_network); then
            return 1
        fi
    fi

    echo "Scanning network $network..."

    if ! check_dependency "nmap"; then
        local pkg_manager
        pkg_manager=$(detect_package_manager)
        if [ "$pkg_manager" != "unknown" ]; then
            read -r -p "Install nmap? (y/N): " install_choice
            if [[ "$install_choice" =~ ^[Yy]$ ]]; then
                if ! install_dependency "nmap" "$pkg_manager"; then
                    log_message "ERROR" "${RED}Could not install nmap. Install manually and retry.${NC}"
                    return 1
                fi
            else
                log_message "ERROR" "${RED}nmap required for scanning. Install manually.${NC}"
                return 1
            fi
        else
            log_message "ERROR" "${RED}nmap required for scanning. Install manually.${NC}"
            return 1
        fi
    fi

    echo "Running scan (30-60 seconds)..."

    local temp_file
    temp_file=$(mktemp)
    nmap "${NMAP_OPTIONS[@]}" "$network" 2>/dev/null | grep -E "Nmap scan report|445/tcp" > "$temp_file"

    local servers=()
    local current_ip=""

    while IFS= read -r line; do
        if [[ "$line" =~ "Nmap scan report for" ]]; then
            current_ip=$(echo "$line" | awk '{print $NF}' | tr -d '()')
        elif [[ "$line" =~ 445/tcp.*open ]] && [ -n "$current_ip" ]; then
            servers+=("$current_ip")
            current_ip=""
        fi
    done < "$temp_file"

    rm "$temp_file"

    if [ ${#servers[@]} -eq 0 ]; then
        echo "No SMB servers found on $network"
        return 1
    fi

    echo "Found ${#servers[@]} SMB server(s)"

    if [ -s "$DISCOVERED_SERVERS_FILE" ]; then
        read -r -p "Refresh discovered servers cache? (y/N): " refresh_choice
        if [[ "$refresh_choice" =~ ^[Yy]$ ]]; then
            : > "$DISCOVERED_SERVERS_FILE"
            echo "Cache cleared. Starting fresh."
        else
            echo "Appending new servers to existing cache..."
        fi
    fi

    for i in "${!servers[@]}"; do
        local ip="${servers[$i]}"
        local hostname=""

        echo "Testing server(5-10s) $ip..."

        hostname=$(nslookup "$ip" 2>/dev/null | grep "name =" | awk '{print $4}' | sed 's/\.$//' | tr '[:upper:]' '[:lower:]')
        if [ -z "$hostname" ] && command -v nmblookup &> /dev/null; then
            hostname=$(nmblookup -A "$ip" 2>/dev/null | grep "<00>" | head -n1 | awk '{print $1}' | tr '[:upper:]' '[:lower:]')
        fi

        if [ -n "$hostname" ]; then
            echo "$((i+1))) $ip ($hostname)"
            echo "$ip:$hostname" >> "$DISCOVERED_SERVERS_FILE"
        else
            echo "$((i+1))) $ip"
            echo "$ip:" >> "$DISCOVERED_SERVERS_FILE"
        fi
    done

    sort -u -o "$DISCOVERED_SERVERS_FILE" "$DISCOVERED_SERVERS_FILE"

    echo "Discovered servers saved to cache"
    echo "Use 'smbmnt -D' to select a found server and scan for shares"
}

scan_shares() {
    local server_ip="$1"
    
    if [ -z "$server_ip" ]; then
        log_message "ERROR" "${RED}Server IP required${NC}"
        return 1
    fi
    
    validate_server "$server_ip" || return 1
    
    log_message "INFO" "${BLUE}Scanning shares on $server_ip...${NC}"
    
    if ! check_dependency "smbclient"; then
        local pkg_manager
        pkg_manager=$(detect_package_manager)
        if [ "$pkg_manager" != "unknown" ]; then
            read -r -p "Install smbclient? (y/N): " install_choice
            if [[ "$install_choice" =~ ^[Yy]$ ]]; then
                if ! install_dependency "smbclient" "$pkg_manager"; then
                    log_message "ERROR" "${RED}Could not install smbclient${NC}"
                    return 1
                fi
            else
                log_message "ERROR" "${RED}smbclient required${NC}"
                return 1
            fi
        else
            log_message "ERROR" "${RED}smbclient required${NC}"
            return 1
        fi
    fi
    
    local shares_output
    if ! shares_output=$(smbclient -L "$server_ip" -N 2>/dev/null); then
        if [ -f "$CREDENTIALS" ]; then
            if ! shares_output=$(smbclient -L "$server_ip" -A "$CREDENTIALS" 2>/dev/null); then
                log_message "ERROR" "${RED}Could not connect to $server_ip${NC}"
                return 1
            fi
        else
            log_message "ERROR" "${RED}Could not connect to $server_ip${NC}"
            return 1
        fi
    fi
    
    local shares
    mapfile -t shares < <(echo "$shares_output" | grep "Disk" | awk '{print $1}' | grep -v "^$" | grep -v "IPC\$" | grep -v "print\$" | grep -v "nobody")

    if [ ${#shares[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}No shares found${NC}"
        return 1
    fi
    
    log_message "INFO" "${GREEN}Found ${#shares[@]} shares:${NC}"
    for i in "${!shares[@]}"; do
        log_message "INFO" "   $((i+1))) ${shares[$i]}"
    done
    
    echo
    read -r -p "Auto-configure script with these settings? (y/N): " auto_config
    if [[ "$auto_config" =~ ^[Yy]$ ]]; then
        update_script_config "$server_ip" "${shares[@]}"
    fi
}

update_script_config() {
    local selected_server="$1"
    shift
    local discovered_shares=("$@")

    local script_path="${BASH_SOURCE[0]}"
    local temp_file
    temp_file=$(mktemp)

    while IFS= read -r line; do
        if [[ "$line" =~ ^DEFAULT_SERVER= ]]; then
            echo "DEFAULT_SERVER=\"$selected_server\""
        elif [[ "$line" =~ ^DEFAULT_SHARES= ]]; then
            printf "DEFAULT_SHARES=("
            for share in "${discovered_shares[@]}"; do
                printf "\"%s\" " "$share"
            done
            printf ")\n"
        else
            echo "$line"
        fi
    done < "$script_path" > "$temp_file"

    if ! bash -n "$temp_file" 2>/dev/null; then
        log_message "ERROR" "${RED}Generated configuration has syntax errors - aborting update${NC}"
        rm -f "$temp_file"
        return 1
    fi

    attempt_update() {
        # Method 1: Use install command (most reliable)
        if sudo install -m 755 "$temp_file" "$script_path" 2>/dev/null; then
            return 0
        fi

        if [ -w "$script_path" ]; then
            if mv "$temp_file" "$script_path" 2>/dev/null && chmod +x "$script_path"; then
                return 0
            fi
        else
            if sudo mv "$temp_file" "$script_path" 2>/dev/null && sudo chmod +x "$script_path"; then
                return 0
            fi
        fi

        if [ -w "$script_path" ]; then
            if cat "$temp_file" > "$script_path" 2>/dev/null && chmod +x "$script_path"; then
                return 0
            fi
        else
            if sudo bash -c "cat '$temp_file' > '$script_path'" 2>/dev/null && sudo chmod +x "$script_path"; then
                return 0
            fi
        fi

        return 1
    }

    if attempt_update; then
        log_message "INFO" "${GREEN}Configuration updated! Server: $selected_server, Shares: ${discovered_shares[*]}${NC}"
        SHARES=("${discovered_shares[@]}")
        SERVER="$selected_server"
        rm -f "$temp_file"
        return 0
    else
        log_message "ERROR" "${RED}Failed to update configuration - permission denied${NC}"
        log_message "INFO" "${YELLOW}The script is located in a system directory (/usr/local/bin/)${NC}"
        log_message "INFO" "${YELLOW}Try running the script with sudo: sudo $(basename "$script_path")${NC}"
        log_message "INFO" "${YELLOW}Or move the script to your home directory for easier updates${NC}"
        rm -f "$temp_file"
        return 1
    fi
}

generate_fstab() {
    local choice="$1"

    log_message "INFO" "${BLUE}Generating fstab entries...${NC}"

        local fstab_entries=()
    if [[ "$choice" == "all" ]]; then
        for share in "${SHARES[@]}"; do
            local mount_point="$MOUNT_BASE/samba-${share,,}"
            fstab_entries+=("//$SERVER/$share $mount_point cifs credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),file_mode=0664,dir_mode=0775,vers=$SMB_VERSION,nofail 0 0")
        done
    elif [[ "$choice" =~ ^[0-9,]+$ ]]; then
        IFS=',' read -ra CHOICES <<< "$choice"
        for ch in "${CHOICES[@]}"; do
            ch=$(echo "$ch" | tr -d ' ')
            index=$((ch-1))
            if [ $index -ge 0 ] && [ $index -lt ${#SHARES[@]} ]; then
                local share="${SHARES[$index]}"
                local mount_point="$MOUNT_BASE/samba-${share,,}"
                fstab_entries+=("//$SERVER/$share $mount_point cifs credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),file_mode=0664,dir_mode=0775,vers=$SMB_VERSION,nofail 0 0")
            else
                log_message "ERROR" "${RED}Invalid choice: $ch${NC}"
            fi
        done
    else
        log_message "ERROR" "${RED}Invalid choice: $choice${NC}"
        return 1
    fi

    if [ ${#fstab_entries[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}No valid fstab entries generated${NC}"
        return 1
    fi

    log_message "INFO" "${YELLOW}Adding to /etc/fstab (requires sudo)...${NC}"
    for entry in "${fstab_entries[@]}"; do
        if ! grep -Fxq "$entry" /etc/fstab 2>/dev/null; then
            if echo "$entry" | sudo tee -a /etc/fstab >/dev/null; then
                log_message "INFO" "${GREEN}Added to fstab: $entry${NC}"
            else
                log_message "ERROR" "${RED}Failed to add to fstab: $entry${NC}"
            fi
        else
            log_message "INFO" "${YELLOW}Already in fstab: $entry${NC}"
        fi
    done

    log_message "INFO" "${YELLOW}Run 'sudo mount -a' to apply fstab changes${NC}"
}

show_status() {
    local term_width
    term_width=$(tput cols 2>/dev/null || echo "80")
    
    if [ "$term_width" -lt 60 ]; then
        term_width=60
    elif [ "$term_width" -gt 120 ]; then
        term_width=120
    fi
    
    local border_char="="
    local border
    border=$(printf "%*s" "$term_width" "" | tr ' ' "$border_char")
    local title="SMB Mount Status"
    local title_padding
    title_padding=$(( (term_width - ${#title} - 2) / 2 ))
    local title_line
    title_line=$(printf "%*s %s %*s" "$title_padding" "" "$title" "$title_padding" "")
    
    log_message "INFO" "${PURPLE}"
    log_message "INFO" "$border"
    log_message "INFO" "$title_line"
    log_message "INFO" "$border${NC}"
    
    local mounted_count=0
    
    log_message "INFO" "${CYAN}Currently Mounted SMB Shares:${NC}"
    log_message "INFO" ""
    
    # Dynamic column widths based on terminal size
    local col1_width=20
    local col2_width=25
    local col3_width=15
    local col4_width=10
    
    # Adjust for smaller terminals
    if [ "$term_width" -lt 80 ]; then
        col1_width=15
        col2_width=20
        col3_width=12
        col4_width=8
    fi
    
    printf "%-${col1_width}s %-${col2_width}s %-${col3_width}s %-${col4_width}s\n" "Share Name" "Mount Point" "Server" "Size"
    printf "%-${col1_width}s %-${col2_width}s %-${col3_width}s %-${col4_width}s\n" \
           "$(printf "%*s" "$col1_width" "" | tr ' ' '-')" \
           "$(printf "%*s" "$col2_width" "" | tr ' ' '-')" \
           "$(printf "%*s" "$col3_width" "" | tr ' ' '-')" \
           "$(printf "%*s" "$col4_width" "" | tr ' ' '-')"
    
    for share in "${SHARES[@]}"; do
        local mount_point="$MOUNT_BASE/samba-${share,,}"
        if mountpoint -q "$mount_point" 2>/dev/null || mount | grep -q "$mount_point"; then
            local server_info
            server_info=$(mount | grep "$mount_point" | sed 's/.*\/\/\([^/]*\)\/.*/\1/')
            local size
            size=$(df -h "$mount_point" 2>/dev/null | tail -n1 | awk '{print $2}')
            
            local display_mount="$mount_point"
            if [ ${#display_mount} -gt $col2_width ]; then
                display_mount="...${display_mount: -$((col2_width-3))}"
            fi
            
            printf "%-${col1_width}s %-${col2_width}s %-${col3_width}s %-${col4_width}s\n" \
                   "$share" "$display_mount" "$server_info" "${size:-N/A}"
            ((mounted_count++))
        fi
    done
    
    if [ $mounted_count -eq 0 ]; then
        log_message "INFO" "${YELLOW}   No SMB shares currently mounted${NC}"
    fi
    
    log_message "INFO" ""
    log_message "INFO" "${BLUE}Summary:${NC}"
    log_message "INFO" "   Mounted shares: $mounted_count/${#SHARES[@]}"
    log_message "INFO" "   Default server: $SERVER"
    log_message "INFO" "   Mount base: $MOUNT_BASE"
    log_message "INFO" "   Log file: $LOG_FILE"
    
    if [ -f "$DISCOVERED_SERVERS_FILE" ] && [ -s "$DISCOVERED_SERVERS_FILE" ]; then
        log_message "INFO" ""
        log_message "INFO" "${PURPLE}Recently Discovered Servers:${NC}"
        while IFS=':' read -r ip hostname; do
            if [ -n "$hostname" ]; then
                log_message "INFO" "   • $ip ($hostname)"
            else
                log_message "INFO" "   • $ip"
            fi
        done < "$DISCOVERED_SERVERS_FILE"
    fi
    
    log_message "INFO" ""
    log_message "INFO" "${PURPLE}$border${NC}"
}

show_header() {
    log_message "INFO" "${PURPLE}"
    log_message "INFO" "╔═══════════════════════════════════════════════════════════════════════╗"
    log_message "INFO" "║                     $SCRIPT_NAME v$SCRIPT_VERSION                          ║"
    log_message "INFO" "║                     $SCRIPT_DESCRIPTION                   ║"
    log_message "INFO" "╚═══════════════════════════════════════════════════════════════════════╝${NC}"
}

use_discovered() {
    if [ ! -f "$DISCOVERED_SERVERS_FILE" ] || [ ! -s "$DISCOVERED_SERVERS_FILE" ]; then
        log_message "ERROR" "${RED}No discovered servers found${NC}"
        log_message "INFO" "${YELLOW}Run 'smbmnt -S' first${NC}"
        return 1
    fi

    log_message "INFO" "${BLUE}Discovered SMB Servers:${NC}"
    log_message "INFO" ""

    local servers=()
    local i=1

    while IFS=':' read -r ip hostname; do
        if [ -n "$hostname" ]; then
            log_message "INFO" "   ${GREEN}$i) $ip ($hostname)${NC}"
        else
            log_message "INFO" "   ${GREEN}$i) $ip${NC}"
        fi
        servers+=("$ip")
        ((i++))
    done < "$DISCOVERED_SERVERS_FILE"

    log_message "INFO" ""

    if [ ${#servers[@]} -eq 1 ]; then
        SERVER="${servers[0]}"
        log_message "INFO" "${GREEN}Using server: $SERVER${NC}"
        log_message "INFO" ""

        read -r -p "Scan for available shares on this server? (y/N): " scan_choice
        if [[ "$scan_choice" =~ ^[Yy]$ ]]; then
            scan_shares "$SERVER"
        fi
    else
        while true; do
            read -r -p "Select server (1-${#servers[@]}): " choice
            if validate_number "$choice" "${#servers[@]}"; then
                local index=$((choice-1))
                SERVER="${servers[$index]}"
                log_message "INFO" "${GREEN}Using server: $SERVER${NC}"
                log_message "INFO" ""

                read -r -p "Scan for available shares on this server? (y/N): " scan_choice
                if [[ "$scan_choice" =~ ^[Yy]$ ]]; then
                    scan_shares "$SERVER"
                fi
                break
            else
                log_message "ERROR" "${RED}Invalid choice. Please enter a number between 1 and ${#servers[@]}${NC}"
            fi
        done
    fi
}

add_to_side_panel() {
    local mount_point="$1"
    local share_name="$2"
    
    log_message "INFO" "${PURPLE}Adding to side panel...${NC}"
    
    GTK_BOOKMARKS="$HOME/.config/gtk-3.0/bookmarks"
    mkdir -p "$(dirname "$GTK_BOOKMARKS")"
    
    if [ -f "$GTK_BOOKMARKS" ]; then
        sed -i "\|$mount_point|d" "$GTK_BOOKMARKS"
    fi
    
    echo "file://$mount_point Samba: $share_name" >> "$GTK_BOOKMARKS"
    
    LINK_PATH="$HOME/Samba-$share_name"
    if [ -L "$LINK_PATH" ]; then
        rm "$LINK_PATH"
    elif [ -e "$LINK_PATH" ]; then
        log_message "WARNING" "${YELLOW}File exists at $LINK_PATH, skipping symlink${NC}"
        return 1
    fi
    
    if ln -s "$mount_point" "$LINK_PATH"; then
        log_message "INFO" "${GREEN}Created symlink: $LINK_PATH${NC}"
    else
        log_message "ERROR" "${RED}Failed to create symlink: $LINK_PATH${NC}"
    fi
}

remove_from_side_panel() {
    local mount_point="$1"
    local share_name="$2"

    log_message "INFO" "${YELLOW}Removing from side panel...${NC}"

    GTK_BOOKMARKS="$HOME/.config/gtk-3.0/bookmarks"
    if [ -f "$GTK_BOOKMARKS" ]; then
        sed -i "\|$mount_point|d" "$GTK_BOOKMARKS"
    fi

    LINK_PATH="$HOME/Samba-$share_name"
    if [ -L "$LINK_PATH" ]; then
        rm "$LINK_PATH"
        log_message "INFO" "${GREEN}Removed symlink: $LINK_PATH${NC}"
    fi
}

mount_share() {
    local share_name="$1"
    local mount_point="$MOUNT_BASE/samba-${share_name,,}"
    local share_path="//$SERVER/$share_name"

    if [[ ! "$share_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_message "ERROR" "${RED}Invalid share name: $share_name${NC}"
        return 1
    fi

    if mountpoint -q "$mount_point" 2>/dev/null || mount | grep -q "$mount_point"; then
        log_message "INFO" "${GREEN}$share_name already mounted at $mount_point${NC}"
        add_to_side_panel "$mount_point" "$share_name"
        return 0
    fi

    if [ ! -d "$mount_point" ]; then
        if ! sudo mkdir -p "$mount_point" || ! sudo chown "$USER:$USER" "$mount_point"; then
            log_message "ERROR" "${RED}Failed to create or set ownership for mount directory: $mount_point${NC}"
            return 1
        fi
    fi

    log_message "INFO" "${BLUE}Mounting $share_name...${NC}"

    if sudo mount -t cifs "$share_path" "$mount_point" -o "credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),file_mode=0664,dir_mode=0775,vers=$SMB_VERSION" 2>>"$LOG_FILE"; then
        log_message "INFO" "${GREEN}$share_name mounted successfully at $mount_point${NC}"
        add_to_side_panel "$mount_point" "$share_name"
        return 0
    else
        log_message "ERROR" "${RED}Mount failed for $share_name. Check $LOG_FILE or dmesg for details.${NC}"
        return 1
    fi
}

unmount_share() {
    local share_name="$1"
    local mount_point="$MOUNT_BASE/samba-${share_name,,}"

    if [[ ! "$share_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_message "ERROR" "${RED}Invalid share name: $share_name${NC}"
        return 1
    fi

    if mountpoint -q "$mount_point" 2>/dev/null || mount | grep -q "$mount_point"; then
        log_message "INFO" "${BLUE}Unmounting $share_name...${NC}"
        if sudo umount "$mount_point" 2>>"$LOG_FILE"; then
            log_message "INFO" "${GREEN}$share_name unmounted successfully${NC}"
            remove_from_side_panel "$mount_point" "$share_name"
            sudo rmdir "$mount_point" 2>/dev/null
        else
            log_message "ERROR" "${RED}Unmount failed for $share_name. Check $LOG_FILE or dmesg for details.${NC}"
            return 1
        fi
    else
        log_message "INFO" "${YELLOW}$share_name is not mounted${NC}"
    fi
}

list_shares() {
    log_message "INFO" "${CYAN}Available shares on $SERVER:${NC}"
    log_message "INFO" "=============================="
    for i in "${!SHARES[@]}"; do
        mount_point="$MOUNT_BASE/samba-${SHARES[$i],,}"
        if mountpoint -q "$mount_point" 2>/dev/null || mount | grep -q "$mount_point"; then
            log_message "INFO" "$((i+1))) ${SHARES[$i]} ${GREEN}[MOUNTED]${NC}"
        else
            log_message "INFO" "$((i+1))) ${SHARES[$i]}"
        fi
    done
}

process_choices() {
    local choice="$1"
    local action="$2"

    if [[ "$choice" == "all" ]]; then
        log_message "INFO" "${BLUE}${action^}ing all shares...${NC}"
        for share in "${SHARES[@]}"; do
            if [ "$action" == "mount" ]; then
                mount_share "$share"
            else
                unmount_share "$share"
            fi
        done
    elif [[ "$choice" =~ ^[0-9,]+$ ]]; then
        IFS=',' read -ra CHOICES <<< "$choice"
        for ch in "${CHOICES[@]}"; do
            ch=$(echo "$ch" | tr -d ' ')
            index=$((ch-1))
            if [ $index -ge 0 ] && [ $index -lt ${#SHARES[@]} ]; then
                if [ "$action" == "mount" ]; then
                    mount_share "${SHARES[$index]}"
                else
                    unmount_share "${SHARES[$index]}"
                fi
            else
                log_message "ERROR" "${RED}Invalid choice: $ch${NC}"
            fi
        done
    else
        log_message "ERROR" "${RED}Invalid choice: $choice${NC}"
        return 1
    fi
}

SERVER="$DEFAULT_SERVER"
CREDENTIALS="$DEFAULT_CREDENTIALS"
SHARES=("${DEFAULT_SHARES[@]}")
UNMOUNT_MODE=false
INTERACTIVE_MODE=true
FSTAB_MODE=false
CHOICE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -ip|--server)
            validate_server "$2" || exit 1
            SERVER="$2"
            shift 2
            ;;
        -c|--credentials)
            CREDENTIALS="$2"
            shift 2
            ;;
        --mount-base)
            MOUNT_BASE="$2"
            shift 2
            ;;
        -ls|--list)
            list_shares
            exit 0
            ;;
        -u|--unmount)
            UNMOUNT_MODE=true
            shift
            ;;
        -S|--scan) 
            NETWORK_ARG=""
            if [[ $# -gt 1 ]] && [[ ! "$2" =~ ^- ]]; then
                NETWORK_ARG="$2"
                shift
            fi
            discover_servers "$NETWORK_ARG"
            exit $?
            ;;
        -Ss|--scan-shares)
            if [[ $# -gt 1 ]] && [[ ! "$2" =~ ^- ]]; then
                scan_shares "$2"
                exit $?
            else
                log_message "ERROR" "${RED}Server IP required for -Ss|--scan-shares${NC}"
                exit 1
            fi
            ;;
        -st|--status)
            show_status
            exit 0
            ;;
        -D|--discovered)
            use_discovered
            shift
            ;;
        --fstab)
            FSTAB_MODE=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        --)
            shift
            break
            ;;
        -*)
            log_message "ERROR" "${RED}Unknown option: $1${NC}"
            show_usage
            exit 1
            ;;
        *)
            CHOICE="$1"
            INTERACTIVE_MODE=false
            shift
            ;;
    esac
done

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_usage
    exit 0
fi

if ! initialize_script; then
    exit 1
fi

if ! check_dependencies; then
    exit 1
fi
check_optional_dependencies

if [ ! -f "$CREDENTIALS" ]; then
    log_message "ERROR" "${RED}Credentials file not found: $CREDENTIALS${NC}"
    log_message "INFO" "${YELLOW}Create it with:${NC}"
    log_message "INFO" "username=your_username"
    log_message "INFO" "password=your_password"
    log_message "INFO" "domain=your_domain (optional)"
    log_message "INFO" "Ensure permissions with: chmod 600 $CREDENTIALS"
    exit 1
fi

if [ -f "$CREDENTIALS" ] && [ "$(stat -c %a "$CREDENTIALS" 2>/dev/null || stat -f %A "$CREDENTIALS" 2>/dev/null)" != "600" ]; then
    log_message "ERROR" "${RED}Credentials file permissions insecure: $CREDENTIALS${NC}"
    log_message "INFO" "${YELLOW}Run: chmod 600 $CREDENTIALS${NC}"
    exit 1
fi

if [ "$INTERACTIVE_MODE" = false ]; then
    if [ "$FSTAB_MODE" = true ]; then
        generate_fstab "$CHOICE"
        exit $?
    elif [ "$UNMOUNT_MODE" = true ]; then
        process_choices "$CHOICE" "unmount"
        exit $?
    else
        process_choices "$CHOICE" "mount"
        exit $?
    fi
fi

log_message "INFO" "${PURPLE}"
log_message "INFO" "╔═══════════════════════════════════════════════════════════════════════╗"
log_message "INFO" "║                      SMB Mount Manager                                ║"
log_message "INFO" "╚═══════════════════════════════════════════════════════════════════════╝${NC}"
log_message "INFO" "${CYAN}Server: $SERVER${NC}"
log_message "INFO" "${CYAN}Credentials: $CREDENTIALS${NC}"
log_message "INFO" ""

if [ "$FSTAB_MODE" = true ]; then
    log_message "INFO" "${YELLOW}FSTAB MODE${NC}"
    list_shares
    log_message "INFO" ""
    read -r -p "Enter choice for fstab (1-${#SHARES[@]}, all, or comma-separated): " choice
    generate_fstab "$choice"
elif [ "$UNMOUNT_MODE" = true ]; then
    log_message "INFO" "${YELLOW}🔌 UNMOUNT MODE${NC}"
    list_shares
    log_message "INFO" ""
    read -r -p "Enter choice to unmount (1-${#SHARES[@]}, all, or comma-separated): " choice
    process_choices "$choice" "unmount" "$DRY_RUN"
else
    list_shares
    log_message "INFO" "all) Mount all shares"
    log_message "INFO" ""
    read -r -p "Enter choice (1-${#SHARES[@]}, all, or comma-separated): " choice
    process_choices "$choice" "mount" "$DRY_RUN"
fi
