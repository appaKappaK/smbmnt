#!/bin/bash
# shellcheck disable=SC2310  # we use set -e and intentional || patterns throughout
set -euo pipefail
IFS=$'\n\t'

SCRIPT_VERSION="3.1.1" 

# $USER detection ‚Äî resolve the real invoking user even under sudo
if [ -n "${SUDO_USER:-}" ]; then
    ACTUAL_USER="$SUDO_USER"
    ACTUAL_USER_HOME=$(getent passwd "$SUDO_USER" 2>/dev/null | cut -d: -f6)
    ACTUAL_USER_HOME="${ACTUAL_USER_HOME:-$HOME}"
elif [ -n "${USER:-}" ]; then
    ACTUAL_USER="$USER"
    ACTUAL_USER_HOME=$(getent passwd "$USER" 2>/dev/null | cut -d: -f6)
    ACTUAL_USER_HOME="${ACTUAL_USER_HOME:-$HOME}"
else
    ACTUAL_USER="$(whoami 2>/dev/null || echo root)"
    ACTUAL_USER_HOME="$HOME"
fi

# validate home directory
if [ ! -d "$ACTUAL_USER_HOME" ] || [ ! -r "$ACTUAL_USER_HOME" ]; then
    echo "Error: Could not determine valid home directory: '$ACTUAL_USER_HOME'"
    exit 1
fi

# defaults (pre config update)
DEFAULT_SERVER="YourSambaIP"
DEFAULT_CREDENTIALS="$ACTUAL_USER_HOME/.smbcredentials"
DEFAULT_SHARES=("ShareName")

# runtime vars
SERVER="$DEFAULT_SERVER"
SHARES=("${DEFAULT_SHARES[@]}")
CREDENTIALS="$DEFAULT_CREDENTIALS"

# mount & SMBversion
# SMB 3.1.1 is the most secure dialect; override with --smb-version if your server requires an older version (e.g. 2.1, 3.0).
MOUNT_BASE="/mnt"
SMB_VERSION="3.1.1"

# network config
NETWORK_SCAN_PREFERENCE="" # 192...|10...|172...
NMAP_OPTIONS=(-Pn -n -p 445 --open --min-rate 1000)

# paths
CACHE_DIR="$ACTUAL_USER_HOME/.cache/smbmnt"
LOG_FILE="$CACHE_DIR/smbmnt.log"
DISCOVERED_SERVERS_FILE="$CACHE_DIR/discovered_servers"
CONFIG_FILE="$(getent passwd "$ACTUAL_USER" | cut -d: -f6)/.config/smbmnt/config"

# global colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

mkdir -p "$CACHE_DIR"
touch "$LOG_FILE" 2>/dev/null && chmod 644 "$LOG_FILE" 2>/dev/null

# Strip ANSI color codes from a string for clean log output
strip_ansi() {
    # printf "%b" interprets escape sequences portably; echo -e is not guaranteed
    printf "%b\n" "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

log_message() {
    local level="$1"
    local message="$2"
    # Write plain text (no ANSI codes) to the log file
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $(strip_ansi "$message")" >> "$LOG_FILE"
    # Print colored output to terminal
    printf "%b\n" "$message"
}

# debug_log: only prints when DEBUG_MODE=true (--debug flag or SMBMNT_DEBUG=true env var)
debug_log() {
    if [ "${DEBUG_MODE:-false}" = true ]; then
        printf "%b\n" "${CYAN}üîç DEBUG: $*${NC}" >&2
        echo "$(date '+%Y-%m-%d %H:%M:%S') [DEBUG] $*" >> "$LOG_FILE"
    fi
}

validate_server() {
    local server="$1"
    local check_type="${2:-}"  # Default to empty string if $2 is not set
    
    debug_log "validate_server START with: '$server', check_type: '$check_type'"

    if [[ "$server" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        debug_log "Matched IP pattern"
        IFS='.' read -ra octets <<< "$server"
        for octet in "${octets[@]}"; do
            if [[ -z "$octet" ]] || [[ ! "$octet" =~ ^[0-9]+$ ]] || \
               [[ "$octet" =~ ^0[0-9]+$ ]] || [ "$octet" -gt 255 ]; then
                debug_log "Invalid octet: '$octet'"
                log_message "ERROR" "${RED}Invalid IPv4 address: $server${NC}"
                return 1
            fi
        done

        if [[ "$check_type" == "check_reachability" ]]; then
            if ! ping -c 1 -W 2 "$server" &>/dev/null; then
                log_message "WARNING" "${YELLOW}Server $server may not be reachable${NC}"
            fi
        fi

        debug_log "IP validation PASSED"
        debug_log "validate_server RETURNING 0"
        return 0

    elif [[ "$server" =~ ^[a-zA-Z0-9.-]+$ ]]; then
        debug_log "Matched hostname pattern"
        
        if [[ "$server" =~ ^- ]] || [[ "$server" =~ -$ ]] || [[ "$server" =~ ^\. ]] || [[ "$server" =~ \.$ ]]; then
            debug_log "Hostname format check FAILED (starts/ends with hyphen or dot)"
            log_message "ERROR" "${RED}Invalid hostname format: $server${NC}"
            return 1
        fi
        debug_log "Hostname format check PASSED"

        if [[ "$check_type" == "check_dns" ]]; then
            debug_log "Checking DNS for: $server"
            if ! getent hosts "$server" &>/dev/null && ! host "$server" &>/dev/null; then
                debug_log "DNS check FAILED"
                log_message "WARNING" "${YELLOW}Hostname $server may not resolve in DNS${NC}"
            else
                debug_log "DNS check PASSED"
            fi
        fi

        debug_log "Hostname validation PASSED"
        debug_log "validate_server RETURNING 0"
        return 0
    else
        debug_log "No pattern matched for: '$server'"
        log_message "ERROR" "${RED}Invalid server format: $server${NC}"
        return 1
    fi
}

validate_number() {
    local input="$1"
    local max="$2"
    local min="${3:-1}"

    if [[ "$input" =~ [\`\;\|\&\(\)\<\>] ]]; then
        debug_log "Input '$input' is not a valid number"
        return 1
    fi

    if [ "$input" -lt "$min" ] || [ "$input" -gt "$max" ]; then
        debug_log "Input '$input' outside range $min-$max"
        return 1
    fi

    return 0
}

# Reject input that contains shell-significant or path-unsafe characters.
# Prints the input unchanged if clean, returns 1 if dangerous characters are found.
# Callers are expected to exit or return on failure ‚Äî this function never mutates.
validate_input() {
    local input="$1"
    local context="${2:-input}"
    # shellcheck disable=SC2016
    if [[ "$input" =~ [\`\;\|\&\$\(\)\<\>] ]]; then
        log_message "ERROR" "${RED}Invalid characters in $context: '$input'${NC}"
        return 1
    fi
    echo "$input"
}

check_dependency() {
    local dep="$1"
    if ! command -v "$dep" &> /dev/null; then
        log_message "ERROR" "${RED}Missing dependency: $dep${NC}"
        return 1
    fi
    return 0
}

# require_dependency is called lazily at the point of use, not globally at startup.
# Only the operations that actually need a tool will enforce its presence.
require_dependency() {
    local dep="$1"
    local hint="${2:-}"
    if ! command -v "$dep" &>/dev/null; then
        log_message "ERROR" "${RED}Required tool not found: $dep${NC}"
        if [ -n "$hint" ]; then
            log_message "INFO" "${YELLOW}Install hint: $hint${NC}"
        fi
        return 1
    fi
    return 0
}

# mountpoint is the only universal requirement ‚Äî needed for any mount/unmount operation.
if ! require_dependency "mountpoint" "Install util-linux (mountpoint is part of it)"; then
    log_message "ERROR" "${RED}Cannot continue without mountpoint${NC}"
    exit 1
fi

run_maybe_sudo() {
    local cmd=("$@")

    # 1) Global override: never use sudo/doas
    if [ "${SMBMNT_NO_SUDO:-false}" = true ]; then
        debug_log "NO_SUDO=true ‚Üí running without escalation: ${cmd[*]}"
        "${cmd[@]}"
        return $?
    fi

    # 2) Already root ‚Üí no escalation needed
    if [ "$(id -u)" -eq 0 ]; then
        debug_log "Running as root ‚Üí ${cmd[*]}"
        "${cmd[@]}"
        return $?
    fi

    # 3) Optional: prefer sudo/doas even if unprivileged works
    if [ "${SMBMNT_PREFER_SUDO:-false}" = true ]; then
        if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
            debug_log "PREFER_SUDO=true ‚Üí sudo ${cmd[*]}"
            sudo "${cmd[@]}"
            return $?
        fi
        if command -v doas >/dev/null; then
            debug_log "PREFER_SUDO=true ‚Üí doas ${cmd[*]}"
            doas "${cmd[@]}"
            return $?
        fi
        debug_log "PREFER_SUDO=true but no sudo/doas available ‚Üí falling back"
    fi

    # 4) Try without sudo first
    debug_log "Trying without sudo: ${cmd[*]}"
    if "${cmd[@]}" 2>/dev/null; then
        return 0
    fi

    # 5) Try sudo if available and passwordless
    if command -v sudo >/dev/null; then
        if sudo -n true 2>/dev/null; then
            debug_log "Trying with sudo: ${cmd[*]}"
            sudo "${cmd[@]}"
            return $?
        else
            debug_log "sudo exists but is not passwordless"
        fi
    fi

    # 6) Try doas if available
    if command -v doas >/dev/null; then
        debug_log "Trying with doas: ${cmd[*]}"
        doas "${cmd[@]}"
        return $?
    fi

    # 7) No escalation path succeeded
    debug_log "Privilege escalation unavailable ‚Üí command failed: ${cmd[*]}"
    return 1
}

show_usage() {
    echo "Usage: smbmnt [OPTIONS] [CHOICE]"
    echo ""
    echo "OPTIONS:"
    echo "  -ip, --server IP          Samba server IP/hostname (default: $DEFAULT_SERVER)"
    echo "  -c, --credentials FILE    Credentials file (default: $DEFAULT_CREDENTIALS)"
    echo "  --mount-base DIR          Base mount directory (default: $MOUNT_BASE)"
    echo "  -ls, --list               List available shares"
    echo "  -u, --unmount [CHOICE]    Unmount shares (with optional choice)"
    echo "  unmount [CHOICE]          Unmount shares (standalone command)"
    echo "  -S, --scan [NETWORK]      Discover SMB servers on network"
    echo "  -Ss, --scan-shares IP     List shares on specific server"
    echo "  -st, --status             Show dashboard"
    echo "  -D, --discovered          Use discovered servers instead of default"
    echo "  --config                  Show current configuration"
    echo "  --reset-config            Reset to default configuration"
    echo "  --fstab [CHOICE]          Generate fstab entries (with optional choice)"
    echo "  --smb-version VER         SMB dialect version (default: $SMB_VERSION, e.g. 2.1, 3.0)"
    echo "  --debug                   Enable debug output (or set SMBMNT_DEBUG=true)"
    echo "  --dry-run                 Preview actions without executing"
    echo "  --version                 Show version"
    echo "  -h, --help                Show this help"
    echo ""
    echo "CHOICE:"
    echo "  1-N               Specific share number"
    echo "  1,2,3             Multiple shares (comma-separated)"
    echo "  all               All shares"
    echo "  (none)            Interactive mode"
    echo ""
    echo "EXAMPLES:"
    echo "  Mount Operations:"
    echo "    smbmnt                          # Interactive mount mode"
    echo "    smbmnt all                      # Mount all shares"
    echo "    smbmnt 1,3                      # Mount shares 1 and 3"
    echo "    smbmnt --dry-run all            # Preview mount without executing"
    echo ""
    echo "  Unmount Operations:"
    echo "    smbmnt -u                       # Interactive unmount mode"
    echo "    smbmnt -u all                   # Unmount all shares"
    echo "    smbmnt unmount 2                # Unmount share 2 (standalone)"
    echo "    smbmnt --dry-run -u all         # Preview unmount without executing"
    echo ""
    echo "  Discovery & Configuration:"
    echo "    smbmnt -S                       # Discover servers on local network"
    echo "    smbmnt -S 192.168.0.0/24        # Scan specific network"
    echo "    smbmnt -Ss 10.8.0.1             # Scan shares on specific server"
    echo "    smbmnt -D                       # Use discovered server"
    echo "    smbmnt --fstab                  # Generate fstab entries (optional)"
    echo "    smbmnt --fstab all              # Generate fstab for all shares"
    echo "    smbmnt --fstab 1,3              # Generate fstab for shares 1 and 3"
    echo "    smbmnt --config                 # Show current configuration"
    echo ""
    echo "  Dry-run Examples:"
    echo "    smbmnt --dry-run all            # Preview mounting all shares"
    echo "    smbmnt --dry-run -u all         # Preview unmounting all shares"
    echo "    smbmnt --dry-run --fstab all    # Preview fstab generation"
    echo ""
}

# Parse the config file safely using grep/awk instead of sourcing,
# to avoid executing arbitrary code from a potentially tampered file.
load_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        debug_log "No config file found ‚Äî using defaults"
        SERVER="$DEFAULT_SERVER"
        SHARES=("${DEFAULT_SHARES[@]}")
        return 0
    fi

    debug_log "Loading config from: $CONFIG_FILE"

    local parsed_server=""
    local parsed_shares_raw=""
    local parsed_shares=()

    # Extract SERVER="value"
    parsed_server=$(grep -E '^SERVER="[^"]+"' "$CONFIG_FILE" | head -n1 | sed 's/^SERVER="\([^"]*\)".*/\1/' || true)
    debug_log "Parsed SERVER: '$parsed_server'"

    # Extract SHARES=(...)
    parsed_shares_raw=$(sed -n 's/^SHARES=(\(.*\))$/\1/p' "$CONFIG_FILE" | head -n1 || true)
    debug_log "Parsed SHARES raw: '$parsed_shares_raw'"

    # Validate SERVER
    if [ -z "$parsed_server" ]; then
        log_message "WARNING" "${YELLOW}Config missing SERVER entry ‚Äî using defaults${NC}"
        SERVER="$DEFAULT_SERVER"
        SHARES=("${DEFAULT_SHARES[@]}")
        return 1
    fi

    if ! validate_server "$parsed_server"; then
        log_message "WARNING" "${YELLOW}Invalid SERVER in config ‚Äî using defaults${NC}"
        SERVER="$DEFAULT_SERVER"
        SHARES=("${DEFAULT_SHARES[@]}")
        return 1
    fi

    # Parse SHARES list
    if [ -n "$parsed_shares_raw" ]; then
        while IFS= read -r share; do
            share="${share%\"}"
            share="${share#\"}"

            if [[ "$share" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                parsed_shares+=("$share")
                debug_log "Valid share: '$share'"
            else
                log_message "WARNING" "${YELLOW}Skipping invalid share in config: '$share'${NC}"
            fi
        done < <(echo "$parsed_shares_raw" | tr ' ' '\n' | grep -v '^$')
    fi

    # Validate SHARES
    if [ ${#parsed_shares[@]} -eq 0 ]; then
        log_message "WARNING" "${YELLOW}No valid shares in config ‚Äî using defaults${NC}"
        SERVER="$DEFAULT_SERVER"
        SHARES=("${DEFAULT_SHARES[@]}")
        return 1
    fi

    # Apply config
    SERVER="$parsed_server"
    SHARES=("${parsed_shares[@]}")

    log_message "INFO" "${GREEN}‚úì Loaded config: $SERVER with ${#SHARES[@]} share(s)${NC}"
    debug_log "Final config: SERVER='$SERVER', SHARES=(${SHARES[*]})"

    return 0
}

save_config() {
    local server="$1"
    shift
    local shares=("$@")

    if [ -z "$server" ]; then
        log_message "ERROR" "${RED}Server cannot be empty${NC}"
        return 1
    fi

    if [ ${#shares[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}At least one share must be specified${NC}"
        return 1
    fi

    if ! validate_server "$server"; then
        return 1
    fi

    local config_dir
    config_dir=$(dirname "$CONFIG_FILE")
    if ! mkdir -p "$config_dir" 2>/dev/null; then
        log_message "ERROR" "${RED}Cannot create config directory: $config_dir${NC}"
        return 1
    fi

    if [ -f "$CONFIG_FILE" ]; then
        if ! cp "$CONFIG_FILE" "${CONFIG_FILE}.backup" 2>/dev/null; then
            log_message "WARNING" "${YELLOW}Could not create backup${NC}"
        fi
    fi

    if ! {
        echo "# SMB Mount Manager Configuration"
        echo "# Generated on $(date)"
        echo "# Edit this file to change default server and shares"
        echo ""
        echo "SERVER=\"$server\""
        echo -n "SHARES=("
        for share in "${shares[@]}"; do
            printf '"%s" ' "$share"
        done
        echo ")"
    } > "$CONFIG_FILE" 2>/dev/null; then
        log_message "ERROR" "${RED}Failed to write config file${NC}"
        if [ -f "${CONFIG_FILE}.backup" ]; then
            mv "${CONFIG_FILE}.backup" "$CONFIG_FILE" 2>/dev/null
        fi
        return 1
    fi

    # Verify the file is parseable by our own loader before committing
    if ! grep -qE '^SERVER="[^"]+"' "$CONFIG_FILE"; then
        log_message "ERROR" "${RED}Generated configuration failed validation${NC}"
        if [ -f "${CONFIG_FILE}.backup" ]; then
            mv "${CONFIG_FILE}.backup" "$CONFIG_FILE"
            log_message "INFO" "${YELLOW}Restored previous configuration${NC}"
        fi
        return 1
    fi

    chmod 600 "$CONFIG_FILE" 2>/dev/null

    log_message "INFO" "${GREEN}‚úì Configuration saved to $CONFIG_FILE${NC}"

    SERVER="$server"
    SHARES=("${shares[@]}")

    return 0
}

reset_config() {
    if [ -f "$CONFIG_FILE" ]; then
        # Capture the timestamp once to avoid race between cp and the log message
        local backup_ts
        backup_ts=$(date +%Y%m%d-%H%M%S)
        local backup_file="${CONFIG_FILE}.deleted-${backup_ts}"
        cp "$CONFIG_FILE" "$backup_file"
        rm "$CONFIG_FILE"
        log_message "INFO" "${GREEN}Configuration reset to defaults${NC}"
        log_message "INFO" "${YELLOW}Backup saved as: $backup_file${NC}"

        SERVER="$DEFAULT_SERVER"
        SHARES=("${DEFAULT_SHARES[@]}")
    else
        log_message "INFO" "${YELLOW}No configuration file to reset${NC}"
        log_message "INFO" "${BLUE}Already using defaults:${NC}"
        log_message "INFO" "  Server: $DEFAULT_SERVER"
        log_message "INFO" "  Shares: ${DEFAULT_SHARES[*]}"
    fi
}

show_config() {
    log_message "INFO" "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    log_message "INFO" "${CYAN}‚ïë                    Current Configuration                              ‚ïë${NC}"
    log_message "INFO" "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    log_message "INFO" ""
    log_message "INFO" "${BLUE}Active Settings:${NC}"
    log_message "INFO" "  Server: ${GREEN}$SERVER${NC}"
    log_message "INFO" "  Shares: (${#SHARES[@]} total)"
    for i in "${!SHARES[@]}"; do
        log_message "INFO" "    $((i+1)). ${SHARES[$i]}"
    done
    log_message "INFO" ""

    if [ -f "$CONFIG_FILE" ]; then
        local last_modified
        last_modified=$(date -r "$CONFIG_FILE" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$CONFIG_FILE" 2>/dev/null)
        log_message "INFO" "${BLUE}Config File:${NC}"
        log_message "INFO" "  Location: $CONFIG_FILE"
        log_message "INFO" "  Modified: $last_modified"
        if [ -f "${CONFIG_FILE}.backup" ]; then
            log_message "INFO" "  Backup:   ${CONFIG_FILE}.backup"
        fi
    else
        log_message "INFO" "${YELLOW}Using default configuration (no config file exists)${NC}"
        log_message "INFO" "  Run 'smbmnt -Ss <server>' to scan and save a configuration"
    fi
    log_message "INFO" ""
}

detect_network() {
    if [ -n "$NETWORK_SCAN_PREFERENCE" ]; then
        echo "$NETWORK_SCAN_PREFERENCE"
        return 0
    fi

    local network
    # Match RFC1918 private IP ranges:
    # 10.0.0.0/8        -> 10.x.x.x
    # 172.16.0.0/12     -> 172.16.x.x through 172.31.x.x
    # 192.168.0.0/16    -> 192.168.x.x
    network=$(ip -4 route show 2>/dev/null | \
              grep -v "default" | \
              grep -E "(^10\.|^192\.168\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.)" | \
              awk '{print $1}' | \
              head -n1)

    if [ -z "$network" ]; then
        local gateway
        gateway=$(ip route show default 2>/dev/null | awk '{print $3}' | head -n1)
        if [ -n "$gateway" ]; then
            if [[ "$gateway" =~ ^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})\.[0-9]{1,3}$ ]]; then
                network="${BASH_REMATCH[1]}.0/24"
            else
                network=$(echo "$gateway" | sed 's/\.[0-9]*$/\.0\/24/')
            fi
        fi
    fi

    if [ -z "$network" ]; then
        log_message "ERROR" "${RED}Could not detect network. Run -S <network>.${NC}"
        return 1
    fi

    echo "$network"
}

discover_servers() {
    local network
    local raw_network="$1"

    if [[ -n "$raw_network" ]] && [[ ! "$raw_network" =~ ^[0-9./]+$ ]]; then
        log_message "ERROR" "${RED}Invalid network argument: '$raw_network'${NC}"
        return 1
    fi
    network="$raw_network"

    if [ -z "$network" ]; then
        if ! network=$(detect_network); then
            return 1
        fi
    fi

    if ! require_dependency "nmap" "Install nmap: apt-get install nmap / dnf install nmap"; then
        return 1
    fi

    echo "Scanning network $network..."
    echo "Running scan (30-60 seconds)..."

    local temp_file; temp_file=$(mktemp) || {
        log_message "ERROR" "${RED}Failed to create temp file${NC}"
        return 1
    }
    trap 'rm -f "${temp_file:-}"' EXIT

    # Try nmap normally, then via sudo if needed
    if ! run_maybe_sudo nmap "${NMAP_OPTIONS[@]}" -oG - "$network" | grep "445/open/tcp" > "$temp_file"; then
        echo "‚ö†Ô∏è  nmap failed even with sudo. Scan cannot continue."
        return 1
    fi

    local servers=()
    while IFS= read -r line; do
        local ip
        ip=$(echo "$line" | awk '{print $2}')
        [ -n "$ip" ] && servers+=("$ip")
    done < "$temp_file"

    if [ ${#servers[@]} -eq 0 ]; then
        echo "No SMB servers found on $network"
        return 1
    fi

    echo "Found ${#servers[@]} SMB server(s)"

    if [ -s "$DISCOVERED_SERVERS_FILE" ]; then
        read -r -p "Refresh discovered servers cache? (y/N): " refresh_choice
        if [[ "$refresh_choice" =~ ^[Yy]$ ]]; then
            : > "$DISCOVERED_SERVERS_FILE"
            echo "Cache cleared. Starting fresh."
        else
            echo "Appending new servers to existing cache..."
        fi
    fi

    for i in "${!servers[@]}"; do
        local ip="${servers[$i]}"
        local hostname=""

        echo "Testing server (5-10s) $ip..."

        hostname=$(host "$ip" 2>/dev/null | awk '/domain name pointer/ {sub(/\.$/, "", $NF); print tolower($NF)}' | head -n1 || true)
        if [ -z "$hostname" ] && command -v nmblookup &> /dev/null; then
            hostname=$(nmblookup -A "$ip" 2>/dev/null | grep "<00>" | head -n1 | awk '{print $1}' | tr '[:upper:]' '[:lower:]' || true)
        fi

        if [ -n "$hostname" ]; then
            echo "$((i+1))) $ip ($hostname)"
            echo "$ip:$hostname" >> "$DISCOVERED_SERVERS_FILE"
        else
            echo "$((i+1))) $ip"
            echo "$ip:" >> "$DISCOVERED_SERVERS_FILE"
        fi
    done

    sort -u -o "$DISCOVERED_SERVERS_FILE" "$DISCOVERED_SERVERS_FILE"

    echo "Discovered servers saved to cache"
    echo "Use 'smbmnt -D' to select a found server and scan for shares"
}

scan_shares() {
    local server_ip="$1"

    if [ -z "$server_ip" ]; then
        log_message "ERROR" "${RED}Server IP required${NC}"
        return 1
    fi

    validate_server "$server_ip" || return 1

    log_message "INFO" "${BLUE}Scanning shares on $server_ip...${NC}"

    # smbclient is only required for share enumeration ‚Äî enforce it here
    if ! require_dependency "smbclient" "apt-get install smbclient / dnf install samba-client / pacman -S smbclient"; then
        return 1
    fi

    local shares_output=""

    #
    # 1) Try credentialed access first (modern SMB servers)
    #
    if [ -f "$CREDENTIALS" ]; then
        if ! shares_output=$(run_maybe_sudo smbclient -L "$server_ip" -A "$CREDENTIALS" 2>/dev/null); then
            # 2) Credentials failed ‚Üí try guest
            if ! shares_output=$(run_maybe_sudo smbclient -L "$server_ip" -N 2>/dev/null); then
                echo "‚ö†Ô∏è  smbclient failed even with sudo. Cannot scan shares."
                return 1
            fi
        fi

    else
        #
        # No credentials file ‚Üí try guest first
        #
        if ! shares_output=$(run_maybe_sudo smbclient -L "$server_ip" -N 2>/dev/null); then
            echo "‚ö†Ô∏è  smbclient failed even with sudo. Cannot scan shares."
            echo "   Create a credentials file or run: sudo smbmnt -Ss $server_ip"
            return 1
        fi
    fi

    #
    # 3) Parse shares
    #
    local shares
    mapfile -t shares < <(echo "$shares_output" | \
        grep "Disk" | \
        awk '{print $1}' | \
        grep -v "^$" | \
        grep -v "IPC\$" | \
        grep -v "print\$" | \
        grep -v "nobody")

    if [ ${#shares[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}No shares found${NC}"
        return 1
    fi

    log_message "INFO" "${GREEN}Found ${#shares[@]} shares:${NC}"
    for i in "${!shares[@]}"; do
        log_message "INFO" "   $((i+1))) ${shares[$i]}"
    done

    echo
    read -r -p "Save these settings to your configuration? (y/N): " auto_config
    if [[ "$auto_config" =~ ^[Yy]$ ]]; then
        if update_script_config "$server_ip" "${shares[@]}"; then
            log_message "INFO" "${CYAN}Run 'smbmnt' to mount shares${NC}"
            return 0
        fi
    fi
}

update_script_config() {
    local selected_server="$1"
    shift
    local discovered_shares=("$@")

    log_message "INFO" "${BLUE}Saving configuration...${NC}"

    if save_config "$selected_server" "${discovered_shares[@]}"; then
        log_message "INFO" "${GREEN}‚úì Server: $selected_server${NC}"
        log_message "INFO" "${GREEN}‚úì Shares: ${discovered_shares[*]}${NC}"
        log_message "INFO" ""
        log_message "INFO" "${CYAN}Configuration is now active for this session and future runs${NC}"
        return 0
    else
        log_message "ERROR" "${RED}Failed to save configuration${NC}"
        return 1
    fi
}

# Build a single fstab entry for the given share and mount point
_build_fstab_entry() {
    local share="$1"
    local mount_point="$2"
    echo "//$SERVER/$share $mount_point cifs credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),file_mode=0664,dir_mode=0775,vers=$SMB_VERSION,noexec,nofail 0 0"
}

generate_fstab() {
    local choice="$1"
    local dry_run="${2:-false}"

    log_message "INFO" "${BLUE}Generating fstab entries...${NC}"

    local fstab_entries=()
    local share mount_point entry

    if [ -z "$choice" ]; then
        log_message "ERROR" "${RED}No choice specified for fstab generation${NC}"
        return 1
    fi

    if [[ "$choice" == "all" ]]; then
        for share in "${SHARES[@]}"; do
            mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share,,}"
            if [[ "$mount_point" =~ [[:space:]] ]]; then
                log_message "ERROR" "${RED}Invalid mount point (contains spaces): $mount_point${NC}"
                continue
            fi
            fstab_entries+=("$(_build_fstab_entry "$share" "$mount_point")")
        done
    elif [[ "$choice" =~ ^[0-9,]+$ ]]; then
        IFS=',' read -ra CHOICES <<< "$choice"
        for ch in "${CHOICES[@]}"; do
            ch=$(echo "$ch" | tr -d ' ')
            local index=$((ch-1))
            if [ $index -ge 0 ] && [ $index -lt ${#SHARES[@]} ]; then
                share="${SHARES[$index]}"
                mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share,,}"
                if [[ "$mount_point" =~ [[:space:]] ]]; then
                    log_message "ERROR" "${RED}Invalid mount point (contains spaces): $mount_point${NC}"
                    continue
                fi
                fstab_entries+=("$(_build_fstab_entry "$share" "$mount_point")")
            else
                log_message "ERROR" "${RED}Invalid choice: $ch${NC}"
            fi
        done
    else
        log_message "ERROR" "${RED}Invalid choice: $choice${NC}"
        return 1
    fi

    if [ ${#fstab_entries[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}No valid fstab entries generated${NC}"
        return 1
    fi

    if [ "$dry_run" = true ]; then
        log_message "INFO" "${CYAN}üö´ DRY RUN: Would add these fstab entries:${NC}"
        for entry in "${fstab_entries[@]}"; do
            log_message "INFO" "${CYAN}  üìÑ $entry${NC}"
        done
        log_message "INFO" "${CYAN}No changes were actually made to /etc/fstab.${NC}"
        return 0
    fi

    log_message "INFO" "${YELLOW}Adding to /etc/fstab (requires sudo)...${NC}"

    local added_count=0
    local skipped_count=0
    local error_count=0

    for entry in "${fstab_entries[@]}"; do
        if ! grep -Fxq "$entry" /etc/fstab 2>/dev/null; then
            if echo "$entry" | sudo tee -a /etc/fstab >/dev/null; then
                log_message "INFO" "${GREEN}‚úì Added to fstab: $entry${NC}"
                added_count=$((added_count + 1))
            else
                log_message "ERROR" "${RED}‚úó Failed to add to fstab: $entry${NC}"
                error_count=$((error_count + 1))
            fi
        else
            log_message "INFO" "${YELLOW}‚óã Already in fstab: $entry${NC}"
            skipped_count=$((skipped_count + 1))
        fi
    done

    log_message "INFO" ""
    log_message "INFO" "${CYAN}Summary:${NC}"
    log_message "INFO" "  ${GREEN}Added: $added_count${NC}"
    log_message "INFO" "  ${YELLOW}Skipped (already exists): $skipped_count${NC}"
    if [ $error_count -gt 0 ]; then
        log_message "INFO" "  ${RED}Errors: $error_count${NC}"
    fi

    if [ $added_count -gt 0 ]; then
        log_message "INFO" ""
        log_message "INFO" "${YELLOW}Run 'sudo mount -a' to apply fstab changes${NC}"
    fi

    return $((error_count > 0))
}

show_status() {
    log_message "INFO" "${PURPLE}"
    log_message "INFO" " ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    log_message "INFO" " ‚ïë                        SMB Mount Status                               ‚ïë"
    log_message "INFO" " ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"

    local mounted_count=0

    log_message "INFO" "${CYAN}Currently Mounted SMB Shares:${NC}"
    log_message "INFO" ""

    # Use printf for the header directly ‚Äî this is intentionally not logged
    printf "%-20s %-25s %-15s %-10s\n" "Share Name" "Mount Point" "Server" "Size"
    printf "%-20s %-25s %-15s %-10s\n" "----------" "-----------" "------" "----"

    for share in "${SHARES[@]}"; do
        local mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share,,}"
        if mountpoint -q "$mount_point" 2>/dev/null || grep -q " $mount_point " /proc/mounts 2>/dev/null; then
            local server_info
            server_info=$(grep " $mount_point " /proc/mounts 2>/dev/null | sed 's/.*\/\/\([^/]*\)\/.*/\1/' || true)
            local size
            size=$(df -h "$mount_point" 2>/dev/null | tail -n1 | awk '{print $2}')
            printf "%-20s %-25s %-15s %-10s\n" "$share" "$mount_point" "$server_info" "${size:-N/A}"
            mounted_count=$((mounted_count + 1))
        fi
    done

    if [ $mounted_count -eq 0 ]; then
        log_message "INFO" "${YELLOW}   No SMB shares currently mounted${NC}"
    fi

    log_message "INFO" ""
    log_message "INFO" "${BLUE}Summary:${NC}"
    log_message "INFO" "   Mounted shares: $mounted_count/${#SHARES[@]}"
    log_message "INFO" "   Default server: $SERVER"

    if [ -f "$CONFIG_FILE" ]; then
        log_message "INFO" "   Config source:  ${GREEN}$CONFIG_FILE${NC}"
    else
        log_message "INFO" "   Config source:  ${YELLOW}Built-in defaults${NC}"
    fi

    log_message "INFO" "   Mount base: $MOUNT_BASE"
    log_message "INFO" "   Log file: $LOG_FILE"

    if [ -f "$DISCOVERED_SERVERS_FILE" ] && [ -s "$DISCOVERED_SERVERS_FILE" ]; then
        log_message "INFO" ""
        log_message "INFO" "${PURPLE}Recently Discovered Servers:${NC}"
        while IFS=':' read -r ip hostname; do
            if [ -n "$hostname" ]; then
                log_message "INFO" "   ‚Ä¢ $ip ($hostname)"
            else
                log_message "INFO" "   ‚Ä¢ $ip"
            fi
        done < "$DISCOVERED_SERVERS_FILE"
    fi

    log_message "INFO" ""
    log_message "INFO" "${CYAN}Run 'smbmnt --config' to view detailed configuration${NC}"
}

use_discovered() {
    if [ ! -f "$DISCOVERED_SERVERS_FILE" ] || [ ! -s "$DISCOVERED_SERVERS_FILE" ]; then
        log_message "ERROR" "${RED}No discovered servers found${NC}"
        log_message "INFO" "${YELLOW}Run 'smbmnt -S' first to scan for SMB servers${NC}"
        return 1
    fi

    log_message "INFO" "${BLUE}Discovered SMB Servers:${NC}"
    log_message "INFO" ""

    local servers=()
    local hostnames=()
    local i=1

    while IFS=':' read -r ip hostname; do
        if [ -n "$ip" ]; then
            if [ -n "$hostname" ]; then
                log_message "INFO" "   ${GREEN}$i) $ip ($hostname)${NC}"
            else
                log_message "INFO" "   ${GREEN}$i) $ip${NC}"
            fi
            servers+=("$ip")
            hostnames+=("$hostname")
            i=$((i + 1))
        fi
    done < "$DISCOVERED_SERVERS_FILE"

    log_message "INFO" ""
    log_message "INFO" "   ${YELLOW}0) Cancel${NC}"
    log_message "INFO" ""

    if [ ${#servers[@]} -eq 0 ]; then
        log_message "ERROR" "${RED}No valid servers found in cache${NC}"
        return 1
    fi

    if [ ${#servers[@]} -eq 1 ]; then
        SERVER="${servers[0]}"
        local selected_hostname="${hostnames[0]}"

        if [ -n "$selected_hostname" ]; then
            log_message "INFO" "${CYAN}Only one server found: $SERVER ($selected_hostname)${NC}"
        else
            log_message "INFO" "${CYAN}Only one server found: $SERVER${NC}"
        fi

        log_message "INFO" ""

        read -r -p "Use and scan this server? (Y/n): " scan_choice
        if [[ "$scan_choice" =~ ^[Yy]$ || -z "$scan_choice" ]]; then
            scan_shares "$SERVER"
        else
            log_message "INFO" "${YELLOW}Skipping server${NC}"
            return 1
        fi
    else
        while true; do
            read -r -p "Select server (0-${#servers[@]}): " choice

            if [ "$choice" = "0" ]; then
                log_message "INFO" "${YELLOW}Selection cancelled${NC}"
                return 1
            fi

            if validate_number "$choice" "${#servers[@]}"; then
                local index=$((choice-1))
                SERVER="${servers[$index]}"
                local selected_hostname="${hostnames[$index]}"

                if [ -n "$selected_hostname" ]; then
                    log_message "INFO" "${GREEN}Selected server: $SERVER ($selected_hostname)${NC}"
                else
                    log_message "INFO" "${GREEN}Selected server: $SERVER${NC}"
                fi

                log_message "INFO" ""

                read -r -p "Scan for available shares on this server? (Y/n): " scan_choice
                if [[ "$scan_choice" =~ ^[Yy]$ || -z "$scan_choice" ]]; then
                    scan_shares "$SERVER"
                else
                    log_message "INFO" "${YELLOW}Skipping share scan${NC}"
                fi
                break
            else
                log_message "ERROR" "${RED}Invalid choice. Please enter a number between 0 and ${#servers[@]}${NC}"
            fi
        done
    fi

    return 0
}

# GTK bookmark integration and home directory symlinks removed in v3.0.2.4.
# This is a CLI tool ‚Äî desktop-specific hooks are out of scope.

mount_share() {
    local share_name="$1"
    local dry_run="${2:-false}"
    local mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share_name,,}"
    local share_path="//$SERVER/$share_name"

    # Validate share name
    if [[ ! "$share_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_message "ERROR" "${RED}Invalid share name: $share_name${NC}"
        return 1
    fi

    # Guard against absurdly long paths
    if [ ${#mount_point} -ge 4096 ]; then
        log_message "ERROR" "${RED}Mount point path too long: $mount_point${NC}"
        return 1
    fi

    # DRY RUN
    if [ "$dry_run" = true ]; then
        log_message "INFO" "${CYAN}üö´ DRY RUN: Would mount share:${NC}"
        log_message "INFO" "${CYAN}  üìÅ Share: $share_name${NC}"
        log_message "INFO" "${CYAN}  üìç Mount point: $mount_point${NC}"
        log_message "INFO" "${CYAN}  üîó Source: $share_path${NC}"
        log_message "INFO" "${CYAN}  üë§ Options: credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),vers=$SMB_VERSION${NC}"

        mountpoint -q "$mount_point" && log_message "INFO" "${CYAN}  ‚ÑπÔ∏è  Already mounted${NC}"
        [ ! -d "$mount_point" ] && log_message "INFO" "${CYAN}  üìÇ Would create directory: $mount_point${NC}"
        return 0
    fi

    # Already mounted?
    if mountpoint -q "$mount_point"; then
        log_message "INFO" "${GREEN}$share_name already mounted at $mount_point${NC}"
        return 0
    fi

    # Ensure mount directory exists
    if [ ! -d "$mount_point" ]; then
        debug_log "Creating mount directory: $mount_point"

        if ! mkdir -p "$mount_point" 2>/dev/null; then
            if ! run_maybe_sudo mkdir -p "$mount_point"; then
                log_message "ERROR" "${RED}Failed to create mount directory: $mount_point${NC}"
                return 1
            fi
        fi

        run_maybe_sudo chown "$ACTUAL_USER:$ACTUAL_USER" "$mount_point" 2>/dev/null || true
    fi

    # Mount options
    local mount_options
    mount_options="credentials=$CREDENTIALS,uid=$(id -u),gid=$(id -g),file_mode=0664,dir_mode=0775,vers=$SMB_VERSION,noexec"

    log_message "INFO" "${BLUE}Mounting $share_name...${NC}"

    # Try mount without sudo
    if mount -t cifs "$share_path" "$mount_point" -o "$mount_options" 2>>"$LOG_FILE"; then
        log_message "INFO" "${GREEN}$share_name mounted successfully at $mount_point${NC}"
        return 0
    fi

    # Try mount with sudo/doas
    if run_maybe_sudo mount -t cifs "$share_path" "$mount_point" -o "$mount_options" 2>>"$LOG_FILE"; then
        log_message "INFO" "${GREEN}$share_name mounted successfully at $mount_point (sudo)${NC}"
        return 0
    fi

    log_message "ERROR" "${RED}Mount failed for $share_name${NC}"
    run_maybe_sudo rmdir "$mount_point" 2>/dev/null
    return 1
}

unmount_share() {
    local share_name="$1"
    local dry_run="${2:-false}"
    local mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share_name,,}"

    if [[ ! "$share_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_message "ERROR" "${RED}Invalid share name: $share_name${NC}"
        return 1
    fi

    # DRY RUN
    if [ "$dry_run" = true ]; then
        log_message "INFO" "${CYAN}üö´ DRY RUN: Would unmount share:${NC}"
        log_message "INFO" "${CYAN}  üìÅ Share: $share_name${NC}"
        log_message "INFO" "${CYAN}  üìç Mount point: $mount_point${NC}"

        if mountpoint -q "$mount_point"; then
            log_message "INFO" "${CYAN}  ‚úÖ Currently mounted - would unmount${NC}"
            command -v lsof &>/dev/null && lsof "$mount_point" &>/dev/null && \
                log_message "INFO" "${CYAN}  ‚ö†Ô∏è  Warning: Mount point may be busy${NC}"
        else
            log_message "INFO" "${CYAN}  ‚ÑπÔ∏è  Not currently mounted${NC}"
        fi

        log_message "INFO" "${CYAN}  üìÇ Would remove directory if empty: $mount_point${NC}"
        return 0
    fi

    # Not mounted?
    if ! mountpoint -q "$mount_point"; then
        log_message "INFO" "${YELLOW}$share_name is not mounted${NC}"
        return 0
    fi

    log_message "INFO" "${BLUE}Unmounting $share_name...${NC}"

    # Try unmount without sudo
    if umount "$mount_point" 2>>"$LOG_FILE"; then
        log_message "INFO" "${GREEN}$share_name unmounted successfully${NC}"
        rmdir "$mount_point" 2>/dev/null || true
        return 0
    fi

    # Try unmount with sudo/doas
    if run_maybe_sudo umount "$mount_point" 2>>"$LOG_FILE"; then
        log_message "INFO" "${GREEN}$share_name unmounted successfully (sudo)${NC}"
        run_maybe_sudo rmdir "$mount_point" 2>/dev/null || true
        return 0
    fi

    # Still mounted ‚Üí likely busy
    log_message "ERROR" "${RED}Unmount failed for $share_name${NC}"

    if command -v lsof &>/dev/null && lsof "$mount_point" &>/dev/null; then
        log_message "INFO" "${YELLOW}Share is busy ‚Äî close open files/folders and retry${NC}"
    else
        log_message "INFO" "${YELLOW}Unmount failed ‚Äî the share may be in use or the connection was lost${NC}"
    fi

    return 1
}

mount_all_shares() {
    local dry_run="${1:-false}"

    log_message "INFO" "${BLUE}Mounting all shares...${NC}"

    local success=0
    local failed=0

    for share in "${SHARES[@]}"; do
        log_message "INFO" "${BLUE}Mounting $share...${NC}"

        if mount_share "$share" "$dry_run"; then
            success=$((success + 1))
        else
            failed=$((failed + 1))
        fi
    done

    log_message "INFO" ""
    log_message "INFO" "${CYAN}Summary:${NC}"
    log_message "INFO" "  ${GREEN}Mounted: $success${NC}"
    log_message "INFO" "  ${RED}Failed:  $failed${NC}"

    [ "$failed" -eq 0 ]
}

unmount_all_shares() {
    local dry_run="${1:-false}"

    log_message "INFO" "${BLUE}Unmounting all shares...${NC}"

    local success=0
    local failed=0

    for share in "${SHARES[@]}"; do
        log_message "INFO" "${BLUE}Unmounting $share...${NC}"

        if unmount_share "$share" "$dry_run"; then
            success=$((success + 1))
        else
            failed=$((failed + 1))
        fi
    done

    log_message "INFO" ""
    log_message "INFO" "${CYAN}Summary:${NC}"
    log_message "INFO" "  ${GREEN}Unmounted: $success${NC}"
    log_message "INFO" "  ${RED}Failed:     $failed${NC}"

    [ "$failed" -eq 0 ]
}

list_shares() {
    log_message "INFO" "${CYAN}Available shares on $SERVER:${NC}"
    log_message "INFO" "$(printf '=%.0s' {1..50})"

    #
    # 1) Server reachability check
    #
    local reachable=true
    local dns_ok=true

    # DNS check if hostname
    if [[ "$SERVER" =~ [a-zA-Z] ]]; then
        if ! getent hosts "$SERVER" >/dev/null 2>&1; then
            dns_ok=false
        fi
    fi

    # Ping check (fast)
    if ! ping -c 1 -W 1 "$SERVER" >/dev/null 2>&1; then
        reachable=false
    fi

    #
    # 2) Print reachability status
    #
    if [ "$dns_ok" = false ]; then
        log_message "INFO" "${YELLOW}‚ö†Ô∏è  DNS lookup failed for $SERVER${NC}"
    fi

    if [ "$reachable" = true ]; then
        log_message "INFO" "${GREEN}‚úì Server reachable${NC}"
    else
        log_message "INFO" "${RED}‚úó Server unreachable${NC}"
    fi

    log_message "INFO" ""

    #
    # 3) Query server for actual share list (credentials-first, adaptive sudo)
    #
    local server_shares_output=""
    local -a server_shares=()

    # Try credentials first
    if [ -f "$CREDENTIALS" ]; then
        server_shares_output=$(smbclient -L "$SERVER" -A "$CREDENTIALS" 2>/dev/null || true)
        if [ -z "$server_shares_output" ]; then
            # Try guest
            server_shares_output=$(smbclient -L "$SERVER" -N 2>/dev/null || true)
        fi
    else
        # No credentials ‚Üí try guest
        server_shares_output=$(smbclient -L "$SERVER" -N 2>/dev/null || true)
    fi

    # If both failed ‚Üí adaptive sudo
    if [ -z "$server_shares_output" ]; then
        if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
            if [ -f "$CREDENTIALS" ]; then
                server_shares_output=$(sudo smbclient -L "$SERVER" -A "$CREDENTIALS" 2>/dev/null || true)
            fi
            if [ -z "$server_shares_output" ]; then
                server_shares_output=$(sudo smbclient -L "$SERVER" -N 2>/dev/null || true)
            fi
        fi
    fi

    # Parse server share list
    if [ -n "$server_shares_output" ]; then
        mapfile -t server_shares < <(echo "$server_shares_output" | \
            grep "Disk" | awk '{print $1}' | grep -v "^$" | grep -v "IPC\$" | grep -v "print\$" | grep -v "nobody")
    fi

    #
    # 4) List shares with mount + existence + permission status
    #
    local mounted_count=0
    local total_count=${#SHARES[@]}

    for i in "${!SHARES[@]}"; do
        local share="${SHARES[$i]}"
        local mount_point
        mount_point="$MOUNT_BASE/samba-${SERVER//./-}-${share,,}"
        local status=""
        local size_info=""
        local warn_dir=""
        local exists_icon=""
        local exists_color=""

        #
        # Determine existence / permission status
        #
        if printf '%s\n' "${server_shares[@]}" | grep -Fxq "$share"; then
            exists_icon="üü¢"
            exists_color="${GREEN}"
        else
            # If server unreachable ‚Üí unknown
            if [ "$reachable" = false ]; then
                exists_icon="‚ö´"
                exists_color="${YELLOW}"
            else
                exists_icon="üî¥"
                exists_color="${RED}"
            fi
        fi

        #
        # Mounted?
        #
        if mountpoint -q "$mount_point" 2>/dev/null; then
            status="${GREEN}‚óè MOUNTED${NC}"

            # Free space
            if size_info=$(df -h "$mount_point" 2>/dev/null | awk 'NR==2 {print "(" $4 " free)"}'); then
                status="$status ${CYAN}$size_info${NC}"
            fi

            mounted_count=$((mounted_count + 1))
        else
            status="${YELLOW}‚óã UNMOUNTED${NC}"
        fi

        #
        # Warn if directory exists but not mounted
        #
        if [ -d "$mount_point" ] && ! mountpoint -q "$mount_point"; then
            warn_dir="${YELLOW}(dir exists)${NC}"
        fi

        #
        # Print line
        #
        log_message "INFO" "$((i+1))) $share  $status  ${BLUE}$mount_point${NC}  ${exists_color}${exists_icon}${NC} $warn_dir"
    done

    #
    # 5) Summary
    #
    local summary_color="$GREEN"
    if [ "$mounted_count" -eq 0 ]; then
        summary_color="$YELLOW"
    elif [ "$mounted_count" -lt "$total_count" ]; then
        summary_color="$BLUE"
    fi

    log_message "INFO" ""
    log_message "INFO" "${summary_color}Summary: $mounted_count/$total_count shares mounted${NC}"

    #
    # 6) Extra hint if server unreachable
    #
    if [ "$reachable" = false ]; then
        log_message "INFO" "${RED}Note:${NC} Server appears offline ‚Äî share existence cannot be verified."
    fi
}

process_choices() {
    local choice="$1"
    local action="$2"
    local dry_run="${3:-false}"

    # Reject choice strings that contain anything unexpected
    if ! choice=$(validate_input "$choice" "choice"); then
        return 1
    fi

    # Handle "all" using unified helpers
    if [[ "$choice" == "all" ]]; then
        log_message "INFO" "${BLUE}${action^}ing all shares...${NC}"
        if [ "$action" == "mount" ]; then
            mount_all_shares "$dry_run"
        else
            unmount_all_shares "$dry_run"
        fi
        return $?
    fi

    # Handle comma-separated numeric choices
    if [[ "$choice" =~ ^[0-9,]+$ ]]; then
        IFS=',' read -ra CHOICES <<< "$choice"
        for ch in "${CHOICES[@]}"; do
            ch=$(echo "$ch" | tr -d ' ')
            local index=$((ch-1))

            if [ $index -ge 0 ] && [ $index -lt ${#SHARES[@]} ]; then
                if [ "$action" == "mount" ]; then
                    mount_share "${SHARES[$index]}" "$dry_run"
                else
                    unmount_share "${SHARES[$index]}" "$dry_run"
                fi
            else
                log_message "ERROR" "${RED}Invalid choice: $ch${NC}"
            fi
        done
        return 0
    fi

    # Invalid input
    log_message "ERROR" "${RED}Invalid choice: $choice${NC}"
    return 1
}

main() {
    local action="mount"
    local choice=""
    local dry_run=false
    local use_discovered_flag=false
    local scan_network=""
    local scan_server=""
    local show_status_flag=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            all)
                choice="all"
                ;;
            [0-9]*)
                choice="$1"
                ;;
            -u|--unmount|unmount)
                action="unmount"
                if [[ "${2:-}" =~ ^(all|[0-9,]+)$ ]]; then
                    choice="$2"
                    shift
                fi
                ;;
            --dry-run)
                dry_run=true
                ;;
            -D|--discovered)
                use_discovered_flag=true
                ;;
            -S|--scan)
                scan_network="${2:-}"
                shift
                ;;
            -Ss|--scan-shares)
                scan_server="${2:-}"
                shift
                ;;
            -st|--status)
                show_status_flag=true
                ;;
            --reset-config)
                reset_config
                exit $?
                ;;
            --config)
                show_config
                exit $?
                ;;
            --fstab)
                local fstab_choice="${2:-all}"
                generate_fstab "$fstab_choice" "$dry_run"
                exit $?
                ;;
            --smb-version)
                SMB_VERSION="$2"
                shift
                ;;
            --version)
                echo "$SCRIPT_VERSION"
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                choice="$1"
                ;;
        esac
        shift
    done

    # Load config before doing anything else
    load_config

    # Use discovered servers
    if [ "$use_discovered_flag" = true ]; then
        use_discovered
        exit $?
    fi

    # Network scan
    if [ -n "$scan_network" ]; then
        discover_servers "$scan_network"
        exit $?
    fi

    # Scan shares on a specific server
    if [ -n "$scan_server" ]; then
        scan_shares "$scan_server"
        exit $?
    fi

    # Status dashboard
    if [ "$show_status_flag" = true ]; then
        show_status
        exit $?
    fi

    # Interactive mode if no choice provided
    if [ -z "$choice" ]; then
        list_shares
        echo ""
        read -r -p "Enter choice (1-${#SHARES[@]}, all, or comma-separated): " choice
        choice=$(echo "$choice" | tr -d '[:space:]')
        process_choices "$choice" "$action" "$dry_run"
        exit $?
    fi

    # Process explicit choice
    process_choices "$choice" "$action" "$dry_run"
}

main "$@"